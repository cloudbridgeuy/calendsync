use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let calendsync_dir = Path::new(&manifest_dir);
    let frontend_dir = calendsync_dir.parent().unwrap().join("frontend");
    let frontend_manifest = frontend_dir.join("manifest.json");
    let frontend_dist = frontend_dir.join("dist");
    let assets_rs_path = calendsync_dir.join("src/assets.rs");
    let dist_symlink = calendsync_dir.join("dist");

    // Rerun if frontend manifest changes
    println!(
        "cargo:rerun-if-changed={}",
        frontend_manifest.to_string_lossy()
    );
    println!(
        "cargo:rerun-if-changed={}",
        frontend_dir.join("src/ts").to_string_lossy()
    );

    // The frontend crate is built automatically via Cargo dependency
    // (calendsync depends on calendsync_frontend in Cargo.toml)
    // So we just need to create the symlink and generate assets.rs

    // Create symlink from calendsync/dist -> ../frontend/dist
    if !dist_symlink.exists() {
        #[cfg(unix)]
        {
            std::os::unix::fs::symlink(&frontend_dist, &dist_symlink)
                .expect("Failed to create dist symlink");
            println!("cargo:warning=Created symlink: {dist_symlink:?} -> {frontend_dist:?}");
        }

        #[cfg(windows)]
        {
            // On Windows, use junction or directory symlink
            std::os::windows::fs::symlink_dir(&frontend_dist, &dist_symlink)
                .expect("Failed to create dist symlink");
            println!("cargo:warning=Created symlink: {dist_symlink:?} -> {frontend_dist:?}");
        }
    }

    // Generate assets.rs
    let assets_rs_content = r#"//! Auto-generated by build.rs - do not edit manually.

use std::collections::HashMap;
use std::sync::LazyLock;

/// Asset manifest mapping original filenames to hashed filenames.
pub static ASSET_MANIFEST: LazyLock<HashMap<String, String>> = LazyLock::new(|| {
    let manifest_json = include_str!("../../frontend/manifest.json");
    serde_json::from_str(manifest_json).expect("Invalid manifest.json")
});

/// Get the hashed filename for an asset.
pub fn get_asset_path(name: &str) -> Option<&str> {
    ASSET_MANIFEST.get(name).map(|s| s.as_str())
}
"#;

    fs::write(&assets_rs_path, assets_rs_content).expect("Failed to write assets.rs");
    println!("cargo:warning=Generated assets.rs");
}
