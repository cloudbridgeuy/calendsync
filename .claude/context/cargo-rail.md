# cargo-rail

cargo-rail is a graph-aware monorepo orchestration tool for Rust workspaces. It consolidates functionality from multiple tools (cargo-hakari, cargo-udeps, cargo-machete, cargo-msrv, cargo-release, paths-filter) into a single binary with 11 dependencies. The tool uses Cargo's actual resolver output rather than syntax parsing, ensuring accurate dependency graph analysis.

## Core Commands

### `affected` and `test`

Graph-aware change detection determines which crates need testing based on file changes and the dependency graph:

```bash
cargo rail affected                    # List affected crates
cargo rail affected --merge-base       # Compare against merge-base (CI-recommended)
cargo rail affected -f cargo-args      # Output: -p crate1 -p crate2
cargo rail test                        # Run tests for affected crates only
cargo rail test --explain              # Show why each crate is affected
```

The command traces transitive dependencies, so changing a core library flags all dependent crates for testing. This replaces hand-maintained `paths-filter` rules in CI.

### `unify`

Dependency unification based on Cargo's resolved output:

```bash
cargo rail unify --check    # Preview changes (exits 1 if drift detected)
cargo rail unify            # Apply to workspace
cargo rail unify --explain  # Show reasoning for each change
cargo rail unify undo       # Restore from backup
```

What it does:

- **Unifies versions**: Writes to `[workspace.dependencies]`, converts members to `workspace = true`
- **Prunes dead features**: Removes features never enabled in the resolved graph
- **Fixes undeclared features**: Adds missing feature declarations to member manifests
- **Detects unused deps**: Flags dependencies not used anywhere (auto-removes on apply)
- **Computes MSRV**: Derives minimum Rust version from dependency graph
- **Pins transitives**: Replaces `cargo-hakari` without a workspace-hack crate

Multi-target aware: runs `cargo metadata` per target triple in parallel, computes feature intersections not unions.

### `release`

Dependency-order publishing with changelog generation:

```bash
cargo rail release check crate/s              # Validate release readiness
cargo rail release run crate/s --bump minor   # Bump, tag, publish
cargo rail release run crate/s --check        # Preview release plan
```

The command handles version bumping, changelog generation, git tagging, and crates.io publishing in dependency order with configurable delays between publishes.

### `split` and `sync`

Extract crates with full git history and bidirectional sync:

```bash
cargo rail split init crate/s         # Configure extraction
cargo rail split run crate/s          # Extract with history
cargo rail sync crate/s               # Bidirectional sync
```

Supports three modes: single crate to repo, multiple crates to one repo, and workspace structure mirroring.

## Configuration

Generated by `cargo rail init` at `.config/rail.toml`:

```toml
targets = ["x86_64-unknown-linux-gnu", "aarch64-apple-darwin"]

[unify]
pin_transitives = false      # Enable for hakari replacement
detect_unused = true
prune_dead_features = true
msrv = true
msrv_source = "max"          # deps | workspace | max
enforce_msrv_inheritance = false

[release]
tag_format = "{crate}-{prefix}{version}"
publish_delay = 5            # Seconds between publishes

[change-detection]
infrastructure = [".github/**", "scripts/**", "*.sh"]
```

Configuration file locations searched in order:

1. `rail.toml` (workspace root)
2. `.rail.toml` (workspace root, hidden)
3. `.cargo/rail.toml` (cargo directory)
4. `.config/rail.toml` (config directory)

## GitHub Actions Integration

The `cargo-rail-action` provides CI integration:

```yaml
- uses: actions/checkout@v4
  with:
    fetch-depth: 0  # Required for change detection

- uses: loadingalias/cargo-rail-action@v1
  id: rail

- run: cargo nextest run ${{ steps.rail.outputs.cargo-args }}
  if: steps.rail.outputs.should-test == 'true'
```

### Action Outputs

| Output | Description |
|--------|-------------|
| `docs-only` | `"true"` if only documentation changed |
| `rebuild-all` | `"true"` if infrastructure files changed |
| `crates` | Space-separated affected crates |
| `cargo-args` | Ready-to-use `-p crate1 -p crate2` flags |
| `matrix` | JSON array for `strategy.matrix` |
| `count` | Number of affected crates |

### Matrix Strategy for Parallel Testing

```yaml
jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.affected.outputs.matrix }}
      count: ${{ steps.affected.outputs.count }}
      rebuild-all: ${{ steps.affected.outputs.rebuild-all }}
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - uses: loadingalias/cargo-rail-action@v1
        id: affected

  test:
    needs: detect
    if: |
      needs.detect.outputs.count != '0' &&
      needs.detect.outputs.rebuild-all != 'true'
    strategy:
      fail-fast: false
      matrix:
        crate: ${{ fromJson(needs.detect.outputs.matrix) }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo test -p ${{ matrix.crate }}
```

## Relevance to calendsync

cargo-rail offers several capabilities that could enhance the calendsync development workflow:

### CI Enhancement Opportunities

The `affected` command could replace the current "test everything" CI approach. With 7 workspace crates (calendsync, core, client, frontend, ssr, ssr_core, src-tauri), graph-aware testing would skip unchanged crates. The GitHub Action provides native integration with outputs formatted for GitHub Actions matrix strategy.

Custom change-detection categories allow conditional job triggering:

```toml
[change-detection.custom]
frontend = ["crates/frontend/**"]
ios = ["crates/src-tauri/**", "*.xcodeproj/**"]
```

### xtask Enhancement Opportunities

The `unify` command addresses several checks currently in `cargo xtask lint`:

- **Unused dependency detection**: Currently handled by `cargo-machete`; cargo-rail's `detect_unused` provides equivalent functionality
- **Dead feature pruning**: No current equivalent in xtask; could catch unused feature flags
- **MSRV computation**: Automatic rust-version management based on dependency requirements
- **Undeclared feature detection**: Catches workspace feature borrowing issues before they cause publish failures

The `release` command overlaps with `cargo xtask release` functionality but adds changelog generation and crates.io publishing automation.

### Trade-offs

**Advantages**:

- Single tool replaces multiple dependencies
- Resolution-based analysis (more accurate than syntax parsing)
- Native GitHub Actions support with optimized output formats
- Lossless TOML editing preserves comments and formatting

**Considerations**:

- New dependency (11 transitive deps, but replaces several tools)
- Configuration learning curve
- Overlaps with existing xtask functionality; integration requires careful scoping

## Design Decisions

**Resolution-based**: Uses Cargo's actual resolver output, not syntax parsing. If Cargo resolves it, cargo-rail sees it.

**Multi-target**: Runs `cargo metadata --filter-platform` per target in parallel. Computes feature intersections, not unions, with guardrails where it counts.

**System git**: Uses the system `git` binary directly. No libgit2, no gitoxide. Deterministic SHAs.

**Lossless TOML**: Preserves comments and formatting via `toml_edit`.

## External Resources

- [GitHub Repository](https://github.com/loadingalias/cargo-rail)
- [GitHub Action](https://github.com/loadingalias/cargo-rail-action)
- [Configuration Reference](https://github.com/loadingalias/cargo-rail/blob/main/docs/config.md)
- [Command Reference](https://github.com/loadingalias/cargo-rail/blob/main/docs/commands.md)
